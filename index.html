<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>4-Video Scroll Landing â€” Fixed (first video won't stop)</title>
<style>
  html,body {
    margin:0;
    height:100%;
    background:#000;
    font-family:Arial, sans-serif;
    color:#fff;
  }

  .scroll-container {
    height:100vh;
    width:100vw;
    overflow-y:auto;
    scroll-snap-type:y mandatory;
    -webkit-overflow-scrolling: touch;
  }

  .section {
    height:100vh;
    width:100%;
    position:relative;
    scroll-snap-align:start;
    background:#000;
    display:flex;
    justify-content:center;
    align-items:center;
  }

  .video-wrapper {
    max-width: 100%;
    max-height: 100%;
    width: min(100%, calc(100vh * (16 / 9)));
    aspect-ratio: 16 / 9;
    position: relative;
    overflow: hidden;
    background:#000;
    border-radius: 8px;
    box-shadow: 0 8px 30px rgba(0,0,0,0.6);
  }

  .video-wrapper video {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display:block;
    background:#000;
  }

  .center-play {
    position:absolute;
    inset:0;
    display:flex;
    justify-content:center;
    align-items:center;
    pointer-events:none;
    z-index:20;
  }

  .center-play .icon {
    background:rgba(0,0,0,0.45);
    padding:14px;
    border-radius:50%;
    font-size:22px;
    pointer-events:auto;
    cursor:pointer;
    color:white;
    user-select:none;
  }

  @media (max-aspect-ratio: 16/9) {
    .video-wrapper {
      width: 100%;
      height: calc(100vw * (9 / 16));
    }
  }
</style>
</head>
<body>

<div class="scroll-container" id="scrollContainer"></div>

<script>
/* Replace with your Imgur mp4 links */
const videoSources = [
  "https://i.imgur.com/PxZhK0d.mp4",
  "https://i.imgur.com/PxZhK0d.mp4",
  "https://i.imgur.com/PxZhK0d.mp4",
  "https://i.imgur.com/PxZhK0d.mp4"
];

const container = document.getElementById("scrollContainer");

// Build sections
videoSources.forEach((src, i) => {
  const section = document.createElement("section");
  section.className = "section";

  const wrapper = document.createElement("div");
  wrapper.className = "video-wrapper";

  const video = document.createElement("video");
  video.src = src;
  video.playsInline = true;
  video.autoplay = true;
  video.muted = true;            // start muted to allow autoplay reliably
  video.controls = true;
  video.preload = "auto";        // preload for smoother playback
  video.dataset.index = i;

  // mark the first video so observer won't pause it
  if (i === 0) video.dataset.keepPlaying = "true";

  const playOverlay = document.createElement("div");
  playOverlay.className = "center-play";

  const icon = document.createElement("div");
  icon.className = "icon";
  icon.textContent = "âµï¸Ž";
  icon.dataset.videoIndex = i;

  playOverlay.appendChild(icon);
  wrapper.appendChild(video);
  wrapper.appendChild(playOverlay);
  section.appendChild(wrapper);
  container.appendChild(section);
});

// collect videos AFTER DOM creation
const videos = Array.from(document.querySelectorAll("video"));

// IntersectionObserver: auto-play when mostly visible, BUT do NOT pause the first video (keepPlaying)
const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    const vid = entry.target;
    const keepPlaying = vid.dataset.keepPlaying === "true";

    if (entry.intersectionRatio > 0.5) {
      // play when mostly visible
      vid.play().catch(() => {});
    } else {
      // only pause if NOT marked keepPlaying
      if (!keepPlaying) {
        if (!vid.paused) vid.pause();
      }
    }
  });
}, { threshold: [0.5] });

videos.forEach(v => observer.observe(v));

// overlay manual play/pause (also unmutes when user explicitly interacts)
document.querySelectorAll(".icon").forEach(icon => {
  icon.addEventListener("click", (e) => {
    e.stopPropagation();
    const index = Number(icon.dataset.videoIndex);
    const vid = videos[index];

    if (vid.paused) {
      vid.muted = false; // user gesture - safe to unmute
      vid.play().catch(() => {});
      icon.textContent = "â¸ï¸";
    } else {
      vid.pause();
      icon.textContent = "âµï¸Ž";
    }
  });
});

// clicking the section toggles play/pause and unmutes (user gesture)
document.querySelectorAll(".section").forEach((section, index) => {
  section.addEventListener("click", (e) => {
    if (e.target.classList.contains("icon")) return;
    const vid = videos[index];

    if (vid.paused) {
      vid.muted = false;
      vid.play().catch(() => {});
    } else {
      vid.pause();
    }
  });
});

/* AUTO SCROLL + UNMUTE FIRST VIDEO AFTER 1.5s
   This runs once. The first video is marked keepPlaying so the observer won't pause it.
*/
function autoScrollAndUnmuteFirst() {
  // if there's a next section, scroll to it
  const secondSection = container.children[1];
  if (secondSection) {
    container.scrollTo({
      top: secondSection.offsetTop,
      behavior: 'smooth'
    });
  } else {
    // fallback: scroll by one viewport height
    container.scrollTo({
      top: container.clientHeight,
      behavior: 'smooth'
    });
  }

  const firstVideo = videos[0];
  if (!firstVideo) return;

  // Attempt to unmute and play first video. If browser blocks sound autoplay,
  // catch the error and leave the video muted but playing.
  firstVideo.muted = false;
  firstVideo.play().then(() => {
    const icon = document.querySelector('.icon[data-video-index="0"]');
    if (icon) icon.textContent = "â¸ï¸";
  }).catch((err) => {
    console.warn('Autoplay with sound blocked:', err);
    // restore muted so autoplay remains silent and continuous
    firstVideo.muted = true;
    // keep it playing silently (autoplay was likely allowed when muted)
    firstVideo.play().catch(() => {});
    const icon = document.querySelector('.icon[data-video-index="0"]');
    if (icon) icon.textContent = "ðŸ”ˆ";
  });
}

// single, reliable timeout (1.5s)
setTimeout(autoScrollAndUnmuteFirst, 1500);

// If user interacts (scroll/touch) before 1.5s, cancel auto behavior
let userInteracted = false;
const cancelAuto = () => { userInteracted = true; };
container.addEventListener('wheel', cancelAuto, { passive: true });
container.addEventListener('touchstart', cancelAuto, { passive: true });
container.addEventListener('scroll', () => {
  if (userInteracted) return;
  // if user scrolled before the timeout fired, do nothing when timeout fires
}, { passive: true });

</script>
</body>
</html>
